---
title: 'Difference-in-Differences with Multiple Time Periods'
author: "Mingyu Qi"
institute: "The University of Chicago"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: [tamu, tamu-fonts]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      extra_dependencies: ["xcolor"]
      ratio: "16:9"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.retina = 2)
```

```{r, message = FALSE, warning = FALSE, echo = FALSE}
library(tidyverse)
library(kableExtra)
library(here)
library(ggthemes)
library(lfe)
library(did)
library(xaringan)
library(patchwork)
library(bacondecomp)
library(multcomp)
library(fastDummies)
library(magrittr)
library(MCPanel)
library(data.table) 
library(fixest)     
select <- dplyr::select
theme_set(theme_clean() + theme(plot.background = element_blank()))
```

# .center.pull[Outline of Lecture]

$\hspace{2cm}$

1. Overview of Difference-in-Differences (DiD)

2. Two-Way Fixed Effects (TWFE) Estimator

3. Problems with Using TWFE Estimator for DiD with Multiple Time Periods

4. Simulation Examples

5. Alternative Difference-in-Differences Estimators

6. Conclusion and Recommendations

---
# .center.pull[Outline of Lecture]

$\hspace{2cm}$

1. <span style="color:maroon"> Overview of Difference-in-Differences (DiD) </span>

2. Two-Way Fixed Effects (TWFE) Estimator

3. Problems with Using TWFE Estimator for DiD with Multiple Time Periods

4. Simulation Examples

5. Alternative Difference-in-Differences Estimators

6. Conclusion and Recommendations

---
# .center.pull[Difference-in-Differences]

$\hspace{2cm}$

Let us start with a classic difference-in-differences set-up 

  - There are 2 units (treated and control) and 2 time periods (0 and 1).

  - The treated unit (T) receives treatment in the second period. 

  - The control unit (C) is never treated;
  
  - We call this a <span style="color:maroon"> 2x2 DiD </span>.

---
# .center.pull[Difference-in-Differences]

```{r d1, message = FALSE, warning = FALSE, echo = FALSE, fig.align = 'center', fig.width = 10, cache = TRUE}
# make data
data <- tibble(
  Y = c(2, 5, 1, 2),
  Unit = c("Treat", "Treat", "Control", "Control"),
  T = c(0, 1, 0, 1)
)
# plot
data %>% 
  ggplot(aes(x = T, y = Y, group = Unit, color = Unit)) + geom_line(size = 2) + 
  labs(x = "Time", y = "Outcome") + 
  scale_x_continuous(breaks = c(0, 1)) + 
  scale_y_continuous(limits=c(0,5)) +
  scale_colour_brewer(palette = 'Set1') + 
  theme(axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        legend.position = 'bottom',
        legend.title = element_blank(),
        legend.text = element_text(size = 16),
        plot.background = element_blank())
```


---
# .center.pull[Difference-in-Differences]

```{r d2, message = FALSE, warning = FALSE, echo = FALSE, fig.align = 'center', fig.width = 10, cache = TRUE}
data$Y_0 = c(2,3,NA,NA)
  
# plot
data %>% 
  ggplot(aes(x = T, y = Y, group = Unit, color = Unit)) + geom_line(size = 2) + 
  geom_line(aes(x = T, y = Y_0, color = Unit), linetype = "dashed", size = 2) +
  labs(x = "Time", y = "Outcome") + 
  scale_x_continuous(breaks = c(0, 1)) + 
  scale_y_continuous(limits=c(0,5)) +
  scale_colour_brewer(palette = 'Set1') + 
  theme(axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        legend.position = 'bottom',
        legend.title = element_blank(),
        legend.text = element_text(size = 16),
        plot.background = element_blank())+
  annotate("label", y = 4, x = 0.85, label = "Treatment \n Effect") + 
  annotate("segment", x = 1, xend = 1, y = 3, yend = 5, color = "black", size = 1) + 
  annotate("segment", x = 0.92, xend = 1, y = 4, yend = 5, color = "black", 
           linetype = "dashed", size = 2) + 
  annotate("segment", x = 0.92, xend = 1, y = 4, yend = 3, color = "black", 
           linetype = "dashed", size = 2)
```

---
# .center.pull[Outline of Lecture]

$\hspace{2cm}$

1. <span style="color:maroon"> Overview of Difference-in-Differences (DiD) </span>

2. <span style="color:maroon"> Two-Way Fixed Effects (TWFE) Estimator </span>

3. Problems with Using TWFE Estimator for DiD with Multiple Time Periods

4. Simulation Examples

5. Alternative Difference-in-Differences Estimators

6. Conclusion and Recommendations

---
# .center.pull[Two-Way Fixed Effects (TWFE) DiD]

- Building upon <span style="color:maroon"> Angrist & Pischke (2008, p. 228) </span>, we can think of the simple 2x2 DiD as a <span style="color:maroon"> fixed effects estimator </span>.

- Potential Outcomes 
  - $E[Y_{i,t}|D=0]$ = value of outcome for unit $i$ in period $t$ for the <span style="color:maroon"> control </span>.
  - $E[Y_{i,t}|D=1]$ = value of outcome for unit $i$ in period $t$ for the <span style="color:maroon"> treated </span>.
  
- The expected outcome is a *linear function* of unit and time fixed effects
$$E[Y_{i,t}|D=0] =\alpha_i + \alpha_t$$
$$E[Y_{i,t}|D=1] =\alpha_i + \alpha_t + \color{maroon}{\delta} D_{it}$$

- The goal of DiD is to get an *unbiased estimate* of the treatment effect $\color{maroon}{\delta}$.

---
# .center.pull[Two-Way Differencing]

- Difference in expectations for the <span style="color:maroon"> control (C) </span> unit 
  - $E[Y_{i,t}|i = C, t = 0] = \alpha_C + \alpha_0$
  - $E[Y_{i,t}|i = C, t = 1] = \alpha_C + \alpha_1$
  - Difference between time 1 and time 0: $\alpha_1 - \alpha_0$

- Difference in expectations for the <span style="color:maroon"> treated (T) </span> unit 
  - $E[Y_{i,t}|i = T, t = 0] = \alpha_T + \alpha_0$
  - $E[Y_{i,t}|i = T, t = 1] = \alpha_T + \alpha_1 + \color{maroon}{\delta}$
  - Difference between time 1 and time 0: $\alpha_1 - \alpha_0 + \color{maroon}{\delta}$

- If we assume the linear structure of DiD, then unbiased estimate of $\color{maroon}{\delta}$ is:

$$\color{maroon}{\delta} =
    \begin{align*} & \left( E[Y_{i,t}|i = T, t = 1] - E[Y_{i,t}|i = T, t = 0] \right) - \left( E[Y_{i,t}|i = C, t = 1] - E[Y_{i,t}|i = C, t = 0] \right) \end{align*}$$

---
# .center.pull[Two-Way Differencing]

```{r d3, echo = FALSE, fig.align = 'center', fig.width = 10, cache = TRUE}
data %>% 
  group_by(Unit) %>% 
  mutate(Y2 = Y - Y[which(T == 0)]) %>% 
  ggplot(aes(x = T, y = Y, group = Unit, color = Unit)) + 
  geom_line(size = 2) + 
  geom_line(aes(x = T, y = Y2, group = Unit, color = Unit), linetype = "dashed", size = 2) + 
  labs(x = "Time", y = "Outcome") + 
  scale_x_continuous(breaks = c(0,1)) +
  scale_colour_brewer(palette = 'Set1') + 
  theme(axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        legend.position = 'bottom',
        legend.title = element_blank(),
        legend.text = element_text(size = 16),
        plot.background = element_blank()) + 
  annotate("label", y = 2, x = 0.85, label = "Treatment \n Effect") + 
  annotate("segment", x = 1, xend = 1, y = 1, yend = 3, color = "black", size = 1) + 
  annotate("segment", x = 0.92, xend = 1, y = 2, yend = 3, color = "black", 
           linetype = "dashed", size = 2) + 
  annotate("segment", x = 0.92, xend = 1, y = 2, yend = 1, color = "black", 
           linetype = "dashed", size = 2)
```

---
# .center.pull[Regression DiD]

Recall that DiD can be estimated through linear regression of the form:

$$\tag{1} y_{it} = \alpha + \beta_1 TREAT_i + \beta_2 POST_t + \color{maroon}{\delta} (TREAT_i \cdot POST_t) + \epsilon_{it}$$

The coefficients from the regression estimate in (1) recover the same parameters as the two-way differencing we performed earlier:

$$\begin{align*} 
    \alpha &= E[y_{it} | i = C, t = 0] = \alpha_0 + \alpha_C \\
    \\
    \beta_1 &= E[y_{it} | i = T, t = 0] - E[y_{it} | i = C, t= 0] \\ 
    &= (\alpha_0 + \alpha_T) - (\alpha_0 + \alpha_C) = \alpha_T - \alpha_C \\
    \\
    \beta_2 &= E[y_{it} | i = C, t = 1] - E[y_{it} | i = C, t = 0] \\ 
    &= (\alpha_1 + \alpha_C) - (\alpha_0 + \alpha_C) = \alpha_1 - \alpha_0 \\
    \\
    \color{maroon}{\delta} &= \left(E[y_{it} | i = T, t = 1] - E[y_{it} | i = T, t = 0] \right) - \\
    &\hspace{.5cm} \left(E[y_{it} | i = C, t = 1] - E[y_{it} | i = C t = 0] \right)
    \end{align*}$$
    
---
# .center.pull[TWFE DiD]

- Regression DiD provides both estimates of $\color{maroon}{\delta}$ and standard errors for the estimates.

- <span style="color:maroon"> Angrist & Pischke (2008) </span>:
  - "It's also easy to add additional (units) or periods to the regression setup... [and] it's easy to add additional covariates."

- <span style="color:maroon"> Two-way fixed effects estimator <span>:
$$y_{it} = \alpha_i + \alpha_t + \color{maroon}{\delta} D_{it} + \epsilon_{it}$$

  - $\alpha_i$ and $\alpha_t$ are unit and time fixed effects, $D_{it}$ is the unit-time indicator for treatment.
  
  - $TREAT_i$ and $POST_t$ now subsumed by the unit fixed effects $\alpha_i$ and time fixed effects $\alpha_t$, respectively.
  
  - TWFE estimator be easily modified to include covariate matrix $X_{it}$, time trends, dynamic treatment effects estimation, etc. 
  
---
# .center.pull[TWFE DiD]

- Recall the beer tax example we used in the lecture on panel data analysis, where each unit is a state, each time period is a year, the treatment is beer tax rate, and the outcome is traffic fatalities. If we treat beer tax as a binary indicator (e.g., whether there is a increase in beer tax), it will be as same as the example we just went over. 

- TWFE DiD allows us to control for variables that change cross states but are constant over time and variables that change over time but are constant across states. 

- However, <span style="color:maroon"> contemporaneous trends </span> could confound the treatment effect of interest. For instance, coincident changes in DUI punishment may confound the estimated effect of beer tax on traffic fatalities. 

- Researchers often use <span style="color:maroon"> staggered DiD, which means different units receive treatment at different periods in time, </span> to address this concern. In the beer tax example, it means that states increase their beer tax in different years. 

- TWFE DiD with staggered treatment timing is commonly used. Researchers sometimes use an event study version of TWFE to estimate dynamic treatment effects. 

---
# .center.pull[Event Study TWFE]

```{r d4, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', fig.width = 10, cache = TRUE}
# Load and prepare data
dat = fread("https://raw.githubusercontent.com/LOST-STATS/LOST-STATS.github.io/master/Model_Estimation/Data/Event_Study_DiD/bacon_example.csv") 

# Let's create a more user-friendly indicator of which states received treatment
dat[, treat := ifelse(is.na(`_nfd`), 0, 1)]
dat[, time_to_treat := ifelse(treat==1, year - `_nfd`, 0)]

mod_twfe = feols(asmrs ~ i(time_to_treat, treat, ref = -1) + ## Our key interaction: time × treatment status
		  pcinc + asmrh + cases |                    ## Other controls
		  stfips + year,                             ## FEs
		 cluster = ~stfips,                          ## Clustered SEs
		 data = dat)

iplot(mod_twfe, 
      xlab = 'Time to treatment',
      main = 'Dynamic Treatment Effect', 
      xlim = c(-10,10), ylim = c(-30, 30))
axis(1, at = seq(-10, 10, by = 1))
axis(2, at = seq(-30, 30, by = 5))
```

---
# .center.pull[Outline of Lecture]

$\hspace{2cm}$

1. <span style="color:maroon"> Overview of Difference-in-Differences (DiD) </span>

2. <span style="color:maroon"> Two-Way Fixed Effects (TWFE) Estimator </span>

3. <span style="color:maroon"> Problems with Using TWFE Estimator for DiD with Multiple Time Periods </span>

4. Simulation Examples

5. Alternative Difference-in-Differences Estimators

6. Conclusion and Recommendations

---
# .center.pull[Where TWFE Goes Wrong]

- Before 2018, people knew little about how TWFE DiD measures when treatment timing varies, how it compares means across groups, or why different specifications change estimates.

- Recent development in econometrics on the issues with TWFE DiD with staggered treatment timing (<span style="color:maroon"> de Chaisemartin and D’Haultfœuille (2020), Callaway and Sant’Anna (2021), Goodman-Bacon (2021), Sun and Abraham (2021), Borusyak et al. (2022) </span>)

  - TWFE DiD with staggered treatment timing is a <span style="color:maroon"> weighted average of many different 2x2 DiD treatment effects </span>. 
  
  - In case of staggered treatment timing and treatment effect heterogeneity, the TWFE DiD estimates are likely biased.
    
  - The weights are sometimes <span style="color:maroon"> negative </span>, which is due to the issue that <span style="color:maroon"> already-treated units acting as effective comparison units for not-yet-treated units (bad comparisons) </span>.
  
  - Dynamic effect estimates from event study TWFE estimator cannot help to address the problem above. 
  
---
# .center.pull[Bias with TWFE - Goodman-Bacon (2021)]

- **Goodman-Bacon (2021)** provides a clear graphical intuition for the bias. We assume three treatment groups - never treated units (U), early treated units (k), and later treated units (l).

```{r d5, echo = FALSE, warning = FALSE, fig.align = 'center', fig.height = 6, cache = TRUE}
data <- tibble(
  time = 0:100,
  U = seq(5, 12, length.out = 101),
  l = seq(10, 17, length.out = 101) + c(rep(0, 85), rep(15, 16)),
  k = seq(18, 25, length.out = 101) + c(rep(0, 34), rep(10, 67))
) %>% 
  pivot_longer(-time, names_to = "series", values_to = "value")
data %>% 
  ggplot(aes(x = time, y = value, group = series, color = series, shape = series)) + 
  geom_line(size = 2) + geom_point(size = 2) +
  geom_vline(xintercept = c(34, 85)) +
  labs(x = "Time", y = "Units of y") +
  scale_x_continuous(limits = c(0, 100), breaks = c(34, 85), 
                     labels = c(expression('t'['k']^'*'), expression('t'['l']^'*')), 
                     expand = c(0, 0)) + 
  annotate("text", x = 10, y = 21, label = expression('y'['it']^'k'), size = 9) +
  annotate("text", x = 50, y = 16, label = expression('y'['it']^'l'), size = 9) +
  annotate("text", x = 90, y = 14, label = expression('y'['it']^'U'), size = 9) +
  annotate('label', x = 17, y = 3, label = 'PRE(k)') +
  annotate('label', x = 60, y = 3, label = 'MID(k, l)') +
  annotate('label', x = 93, y = 3, label = 'POST(l)') +
  annotate("segment", x = 1, xend = 33, y = 2, yend = 2, color = "black", 
           arrow = arrow(length = unit(0.1, "inches"))) +
  annotate("segment", x = 33, xend = 1, y = 2, yend = 2, color = "black", 
           arrow = arrow(length = unit(0.1, "inches"))) +
  annotate("segment", x = 35, xend = 84, y = 2, yend = 2, color = "black", 
           arrow = arrow(length = unit(0.1, "inches"))) +
  annotate("segment", x = 84, xend = 35, y = 2, yend = 2, color = "black", 
           arrow = arrow(length = unit(0.1, "inches"))) + 
  annotate("segment", x = 86, xend = 99, y = 2, yend = 2, color = "black", 
           arrow = arrow(length = unit(0.1, "inches"))) +
  annotate("segment", x = 99, xend = 86, y = 2, yend = 2, color = "black", 
           arrow = arrow(length = unit(0.1, "inches"))) +
  scale_y_continuous(limits = c(0, 40), expand = c(0, 0)) +
  scale_colour_brewer(palette = 'Set1') + 
  theme(axis.ticks.x = element_blank(),
        legend.position = 'none',
        panel.grid = element_blank(),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        plot.background = element_blank())
```

---
# .center.pull[Bias with TWFE - Goodman-Bacon (2021)]

- **Goodman-Bacon (2021)** shows that we can form four different 2x2 groups in this setting, where the effect can be estimated using the simple regression DiD in each group:

```{r d6, echo = FALSE, warning = FALSE, fig.align = 'center', fig.height = 6, cache = TRUE}
# function to make subplots
make_subplot <- function(omit, keep_dates, colors, breaks, break_expressions, series, 
                         series_x, series_y, break_names, break_loc, arrow_start, arrow_stop, title){
  
  data %>% 
    filter(series != omit & time >= keep_dates[1] & time <= keep_dates[2]) %>% 
    ggplot(aes(x = time, y = value, group = series, color = series, shape = series)) + geom_line() + geom_point() +
    geom_vline(xintercept = breaks) + 
    labs(x = "Time", y = "Units of y") +
    scale_x_continuous(limits = c(0, 105), breaks = breaks, 
                       labels = break_expressions, 
                       expand = c(0, 0)) + 
    annotate("text", x = series_x[1], y = series_y[1], label = series[1]) +
    annotate("text", x = series_x[2], y = series_y[2], label = series[2]) +
    annotate('label', x = break_loc[1], y = 5, label = break_names[1]) +
    annotate('label', x = break_loc[2], y = 5, label = break_names[2]) +
    annotate("segment", x = arrow_start[1], xend = arrow_stop[1], y = 2, yend = 2, color = "black", 
             arrow = arrow(length = unit(0.1, "inches"))) +
    annotate("segment", x = arrow_stop[1], xend = arrow_start[1], y = 2, yend = 2, color = "black", 
             arrow = arrow(length = unit(0.1, "inches"))) +
    annotate("segment", x = arrow_start[2], xend = arrow_stop[2], y = 2, yend = 2, color = "black", 
             arrow = arrow(length = unit(0.1, "inches"))) +
    annotate("segment", x = arrow_stop[2], xend = arrow_start[2], y = 2, yend = 2, color = "black", 
             arrow = arrow(length = unit(0.1, "inches"))) + 
    scale_y_continuous(limits = c(0, 40), expand = c(0, 0)) +
    scale_color_manual(values = c(colors[1], colors[2])) +  
    ggtitle(title) + 
    theme(axis.ticks.x = element_blank(),
          legend.position = 'none',
          panel.grid = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "plain"),
          plot.background = element_blank()) 
 }
p1 <- make_subplot(omit = "l", keep_dates = c(0, 100), colors = c('#E41A1C', '#377EB8'), breaks = 34, 
                   break_expressions = expression('t'['k']^'*'), 
                   series = c(expression('y'['it']^'k'), expression('y'['it']^'U')),
                   series_x = c(10, 90), series_y = c(23, 16), 
                   break_names = c('Pre(k)', 'Post(k)'), break_loc = c(17, 66), 
                   arrow_start = c(1, 35), arrow_stop = c(33, 99), 
                   title = paste('A. Early Group vs. Untreated Group'))
p2 <- make_subplot(omit = "k", keep_dates = c(0, 100), colors = c('#4DAF4A', '#377EB8'), breaks = 85, 
                   break_expressions = expression('t'['l']^'*'), 
                   series = c(expression('y'['it']^'l'), expression('y'['it']^'U')),
                   series_x = c(50, 90), series_y = c(18, 16), 
                   break_names = c('Pre(l)', 'Post(l)'), break_loc = c(50, 95), 
                   arrow_start = c(1, 86), arrow_stop = c(84, 99), 
                   title = paste('B. Late Group vs. Untreated Group'))
p3 <- make_subplot(omit = "U", keep_dates = c(0, 84), colors = c('#E41A1C', '#4DAF4A'), breaks = c(34, 85), 
                   break_expressions = c(expression('t'['k']^'*'), expression('t'['l']^'*')), 
                   series = c(expression('y'['it']^'k'), expression('y'['it']^'l')),
                   series_x = c(10, 50), series_y = c(23, 18), 
                   break_names = c('Pre(k)', 'Mid(k, l)'), break_loc = c(17, 60), 
                   arrow_start = c(1, 35), arrow_stop = c(33, 84), 
                   title = bquote(paste('C. Early Group vs. Late Group, before ', 't'['l']^'*', sep = " ")))
p4 <- make_subplot(omit = "U", keep_dates = c(34, 100), colors = c('#E41A1C', '#4DAF4A'), breaks = c(34, 85), 
                   break_expressions = c(expression('t'['k']^'*'), expression('t'['l']^'*')), 
                   series = c(expression('y'['it']^'k'), expression('y'['it']^'l')),
                   series_x = c(60, 50), series_y = c(36, 18), 
                   break_names = c('Mid(k, l)', 'Post(l)'), break_loc = c(60, 95), 
                   arrow_start = c(35, 86), arrow_stop = c(84, 99), 
                   title = bquote(paste('D. Late Group vs. Early Group, after ', 't'['k']^'*', sep = " ")))
# combine plots
p1 + p2 + p3 + p4 + plot_layout(nrow = 2)
```

---
# .center.pull[Bias with TWFE - Goodman-Bacon (2021)]

- $\color{maroon}{\delta}$ is the weighted average of the four 2x2 treatment effects. The weights are a function of the <span style="color:maroon"> size of the sub-sample, relative size of treatment and control groups, and treatment variance in the sub-sample </span>.

  - Size $N_k$ is calculated as the share of the full sample. 
  
  - For a treatment group that receives treatment at time t, the treatment variance is calculated as $\frac{t}{T}\times(1-\frac{t}{T})$. 
  
- The weights are larger when the size of the sub-sample is larger, treatment and control groups are closer in size, or treatment variance in the sub-sample is larger. 

- All else equal, groups treated closer to middle of panel receive higher weights than those treated earlier or later. This is because such groups have larger treatment variance in the sub-sample. 

- Since the weights are not equal to the sample shares, $\color{maroon}{\delta}$ will not equal the sample $ATT$. 

---
# .center.pull[Bias with TWFE - Goodman-Bacon (2021)]

- The paper further shows that <span style="color:maroon"> $\color{maroon}{\delta} = VWATT + VWCT - \Delta ATT$ </span>

  - $VWATT$: variance-weighted average treatment effect on the treated. 
  
  - $VWCT$: variance-weighted common trend.
  
  - $\Delta ATT$: weighted sum of the change in $ATT$ within a treatment-timing group's post-period and around a later-treated unit's treatment window. TWFE DiD uses already-treated units as effective control for later-treated groups. In case of heterogeneous treatment effect, changes in already-treated groups' outcome values will be contaminated by changes in treatment effects over time. 

- Two sources of potential bias 

  - Treatment effects vary across units: <span style="color:maroon"> the treatment effects of units treated towards the middle of the time window significantly differ from other treatment effects </span>, the TWFE DiD is likely biased.  
  
  - Treatment effects vary across time: <span style="color:maroon"> treatment effect is time-varying within a treated unit, which lead to $\Delta ATT > 0$. </span> In this case, TWFE DiD will yield estimates that are too small or even wrong-signed.  

---
# .center.pull[Outline of Lecture]

$\hspace{2cm}$

1. <span style="color:maroon"> Overview of Difference-in-Differences (DiD) </span>

2. <span style="color:maroon"> Two-Way Fixed Effects (TWFE) Estimator </span>

3. <span style="color:maroon"> Problems with Using TWFE Estimator for DiD with Multiple Time Periods </span>

4. <span style="color:maroon"> Simulation Examples </span>

5. Alternative Difference-in-Differences Estimators

6. Conclusion and Recommendations

---
# .center.pull[Simulation Example]

- Consider two sets of DiD estimates - one where the treatment occurs in one period, and one where the treatment is staggered.

- The data generating process (DGP) is linear: $y_{it} = \alpha_i + \alpha_t + \color{maroon}{\delta_{it}} + \epsilon_{it}$.
  - $\alpha_i, \alpha_t \sim N(0, (0.5)^2)$
  - $\epsilon_{i, t} \sim N\left(0, (0.1)^2\right)$
  
- We will consider two different treatment assignment set ups for $\color{maroon}{\delta_{it}}$.

---
# .center.pull[Simulation 1 - 1 Period Treatment]

- There are 20 states $s$, and 200 units $i$ randomly drawn from the 20 states.

- Data covers years 1990 to 2010, and half the states receive "treatment" in 2000. 

- For every unit incorporated in a treated state, we pull a unit-specific treatment effect from $\mu_i \sim N(0.3, (0.1)^2)$.

- Treatment effects here are trend breaks rather than unit shifts: the accumulated treatment effect $\color{maroon}{\delta_{it}}$ is $\mu_i \times (year - 2000 + 1)$ for years after 2000. 

- We then estimate the average treatment effect as $\color{maroon}{\hat{\delta}}$ from:

$$y_{it} = \hat{\alpha_i} + \hat{\alpha_t} + \color{maroon}{\hat{\delta}} D_{it}$$

- Simulate this data 500 times and plot the distribution of estimates $\color{maroon}{\hat{\delta}}$ and the true effect (red line).

- True effect is a simple average of treatment effects across all years:
$$ \frac{(0.3 + 0.6 + ... + 3.3)}{11} = 1.8 $$

---
# .center.pull[Simulation 1 - 1 Period Treatment]

```{r d7, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', cache = TRUE, fig.width = 10}
# Make Data  ---------------------------------------------
set.seed(19910914)

# Fixed Effects ------------------------------------------------
# unit fixed effects
unit <- tibble(
  unit = 1:200, 
  unit_fe = rnorm(200, 0, 0.5),
  # generate state
  state = sample(1:20, 200, replace = TRUE),
  # generate treatment effect
  mu = rnorm(200, 0.3, 0.1))

# year fixed effects 
year <- tibble(
  year = 1990:2010,
  year_fe = rnorm(21, 0, 0.5))

# Trend Break -------------------------------------------------------------
# Put the states into treatment groups
treat_taus <- tibble(
  # sample the states randomly
  state = sample(1:20, 20, replace = FALSE),
  # place the randomly sampled states into treatment and control states
  treated_unit = sample(c(rep(1, 10), rep(0, 10)), 20, replace = FALSE))

# make main dataset
# full interaction of unit X year 
data <- expand_grid(unit = 1:200, year = 1990:2010) %>% 
  left_join(., unit) %>% 
  left_join(., year) %>% 
  left_join(., treat_taus) %>% 
  # make error term and get treatment indicators and treatment effects
  mutate(error = rnorm(4200, 0, 0.1),
         treat = ifelse(year >= 2000 & treated_unit == 1, 1, 0),
         tau = ifelse(treat == 1, mu, 0)) %>% 
  # calculate cumulative treatment effects
  group_by(unit) %>% 
  mutate(tau_cum = cumsum(tau)) %>% 
  ungroup() %>% 
  # calculate the dep variable
  mutate(dep_var = unit_fe + year_fe + tau_cum + error)

sim1_plot <- data %>% 
  ggplot(aes(x = year, y = dep_var, group = unit)) +
  # unit specific lines
  geom_line(alpha = 1/10, color = "grey") + 
  # group specific averages
  geom_line(
    data = . %>% 
      group_by(treated_unit, year) %>% 
      dplyr::summarize(dep_var = mean(dep_var)),
    aes(x = year, y = dep_var, group = factor(treated_unit),
        color = factor(treated_unit)), size = 1) + 
  scale_y_continuous(limits = c(-10, 10)) + 
  labs(x = "", y = "", color = "Group") + 
  ggtitle("Trends in Outcome Path") +
  geom_vline(xintercept = 1999.5, color = '#4B5F6C',
             linetype = "dashed", size = 1) + 
  scale_color_manual(values = c("#A7473A", "#4B5F6C")) + 
  theme(legend.position = 'bottom',
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5, vjust = 0.5, angle = 360)) +
        scale_color_manual(values = c("#A7473A", "#4B5F6C"), label = c("Control", "Treated")) 

sim1_plot
```

---
# .center.pull[Simulation 1 - 1 Period Treatment]

```{r d8, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', cache = TRUE, fig.width = 10}
# Make Data  ---------------------------------------------
# loop function for one-time DiD shock
DID_onetime <- function(...) {
  
  # Fixed Effects ------------------------------------------------
  # unit fixed effects
  unit <- tibble(
    unit = 1:200, 
    unit_fe = rnorm(200, 0, 0.5),
    # generate state
    state = sample(1:20, 200, replace = TRUE),
    # generate treatment effect
    mu = rnorm(200, 0.3, 0.1))
  
  # year fixed effects 
  year <- tibble(
    year = 1990:2010,
    year_fe = rnorm(21, 0, 0.5))
  
  # Trend Break -------------------------------------------------------------
  # Put the states into treatment groups
  treat_taus <- tibble(
    # sample the states randomly
    state = sample(1:20, 20, replace = FALSE),
    # place the randomly sampled states into treatment and control states
    treated_unit = sample(c(rep(1, 10), rep(0, 10)), 20, replace = FALSE))
  
  # make main dataset
  # full interaction of unit X year 
  data <- expand_grid(unit = 1:200, year = 1990:2010) %>% 
    left_join(., unit) %>% 
    left_join(., year) %>% 
    left_join(., treat_taus) %>% 
    # make error term and get treatment indicators and treatment effects
    mutate(error = rnorm(4200, 0, 0.1),
           treat = ifelse(year >= 2000 & treated_unit == 1, 1, 0),
           tau = ifelse(treat == 1, mu, 0)) %>% 
    # calculate cumulative treatment effects
    group_by(unit) %>% 
    mutate(tau_cum = cumsum(tau)) %>% 
    ungroup() %>% 
    # calculate the dep variable
    mutate(dep_var = unit_fe + year_fe + tau_cum + error)
  
    # run the DID and get the treatment effect estimates
    broom::tidy(felm(dep_var ~ treat | unit + year | 0 | state, data = data,
                     exactDOF = TRUE, cmethod = "reghdfe"))
}
# estimate 500 times 
# set seed
set.seed(19910914)
DID_one_data <- map_dfr(1:500, DID_onetime)
# plot DID estimates
DID_one_data %>% 
  ggplot(aes(x = estimate)) + geom_density(fill = "gray", alpha = 1/2) + 
  geom_vline(xintercept = (0.3 + 0.3*(2010-2000+1))*11/2/11, color = "red", size = 2) + 
  labs(x = "Estimate Size", y = "Density") + 
  theme(axis.title = element_text(size = 14))
```

---
# .center.pull[Simulation 2 - Staggered Treatment]

- Run similar analysis with staggered treatment. 

- The 20 states are randomly assigned into four treatment cohorts (1994, 1998, 2002, and 2004) of size 50.

- DGP is identical, except that now $\color{maroon}{\delta_{it}}$ is equal to $\mu_i \times (year - \tau_g + 1)$ where $\tau_g$ is the treatment assignment year. 

- Again, we estimate this data 500 times and plot the distribution of estimates $\color{maroon}{\hat{\delta}}$ and the true effect (red line).

---
# .center.pull[Simulation 2 - Staggered Treatment]

```{r d9, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', cache = TRUE, fig.width = 10}
# Make Data  ---------------------------------------------
set.seed(19910914)

# Fixed Effects ------------------------------------------------
# unit fixed effects
unit <- tibble(
  unit = 1:200, 
  unit_fe = rnorm(200, 0, 0.5),
  # generate state
  state = sample(1:20, 200, replace = TRUE),
  # generate treatment effect
  mu = rnorm(200, 0.3, 0.1))

# year fixed effects 
year <- tibble(
  year = 1990:2010,
  year_fe = rnorm(21, 0, 0.5))

# Trend Break -------------------------------------------------------------
# Put the states into treatment groups
treat_taus <- tibble(
  # sample the states randomly
  state = sample(1:20, 20, replace = FALSE),
  # place the randomly sampled states into five treatment groups G_g
  cohort_year = sort(rep(c(1994, 1998, 2002, 2006), 5)))

# make main dataset
# full interaction of unit X year 
data <- expand_grid(unit = 1:200, year = 1990:2010) %>% 
  left_join(., unit) %>% 
  left_join(., year) %>% 
  left_join(., treat_taus) %>% 
  # make error term and get treatment indicators and treatment effects
  mutate(error = rnorm(4200, 0, 0.1),
         treat = ifelse(year >= cohort_year, 1, 0),
         tau = ifelse(treat == 1, mu, 0)) %>% 
  # calculate cumulative treatment effects
  group_by(unit) %>% 
  mutate(tau_cum = cumsum(tau)) %>% 
  ungroup() %>% 
  # calculate the dep variable
  mutate(dep_var = unit_fe + year_fe + tau_cum + error)

sim2_plot <- data %>% 
ggplot(aes(x = year, y = dep_var, group = unit)) +
# unit specific lines
geom_line(alpha = 1/10, color = "grey") + 
# group specific averages
geom_line(
  data = . %>% 
    group_by(cohort_year, year) %>% 
    dplyr::summarize(dep_var = mean(dep_var)),
  aes(x = year, y = dep_var, group = factor(cohort_year),
      color = factor(cohort_year)), size = 1) + 
labs(x = "", y = "", color = "Group") + 
ggtitle("Trends in Outcome Path") +
geom_vline(xintercept = 1993.5, color = '#A7473A',
           linetype = "dashed", size = 1) + 
geom_vline(xintercept = 1997.5, color = '#4B5F6C',
           linetype = "dashed", size = 1) + 
geom_vline(xintercept = 2001.5, color = '#51806a',
           linetype = "dashed", size = 1) + 
geom_vline(xintercept = 2005.5, color = 'darkorange',
           linetype = "dashed", size = 1) + 
scale_color_manual(values = c("#A7473A", "#4B5F6C", "#51806a", "darkorange")) + 
scale_y_continuous(limits = c(-10, 10)) + 
theme(legend.position = 'bottom',
      legend.title = element_blank(),
      plot.title = element_text(hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      axis.title.y = element_text(hjust = 0.5, vjust = 0.5, angle = 360))

sim2_plot
```

---
# .center.pull[Simulation 2 - Staggered Treatment]

```{r d10, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', cache = TRUE, fig.width = 10}
## estimate DID model 2 - 50 firms are treated every period, with the treatment effect still = 0.3 on average
# loop function for one-time DiD shock
DID_multiple <- function(...) {
  
  # Fixed Effects ------------------------------------------------
  # unit fixed effects
  unit <- tibble(
    unit = 1:200, 
    unit_fe = rnorm(200, 0, 0.5),
    # generate state
    state = sample(1:20, 200, replace = TRUE),
    # generate treatment effect
    mu = rnorm(200, 0.3, 0.1))
  
  # year fixed effects 
  year <- tibble(
    year = 1990:2010,
    year_fe = rnorm(21, 0, 0.5))
  
  # Trend Break -------------------------------------------------------------
  # Put the states into treatment groups
  treat_taus <- tibble(
    # sample the states randomly
    state = sample(1:20, 20, replace = FALSE),
    # place the randomly sampled states into five treatment groups G_g
    cohort_year = sort(rep(c(1994, 1998, 2002, 2006), 5)))
  
  # make main dataset
  # full interaction of unit X year 
  data <- expand_grid(unit = 1:200, year = 1990:2010) %>% 
    left_join(., unit) %>% 
    left_join(., year) %>% 
    left_join(., treat_taus) %>% 
    # make error term and get treatment indicators and treatment effects
    mutate(error = rnorm(4200, 0, 0.1),
           treat = ifelse(year >= cohort_year, 1, 0),
           tau = ifelse(treat == 1, mu, 0)) %>% 
    # calculate cumulative treatment effects
    group_by(unit) %>% 
    mutate(tau_cum = cumsum(tau)) %>% 
    ungroup() %>% 
    # calculate the dep variable
    mutate(dep_var = unit_fe + year_fe + tau_cum + error)
  
    # run the DID and get the treatment effect estimates
    broom::tidy(felm(dep_var ~ treat | unit + year | 0 | state, data = data,
                     exactDOF = TRUE, cmethod = "reghdfe"))
}
# set seed
set.seed(19910914)
DID_multiple <- map_dfr(1:500, DID_multiple)
# plot DID estimates
DID_multiple %>% 
ggplot(aes(x = estimate)) + geom_density(fill = "gray", alpha = 1/2) + 
  geom_vline(xintercept = (0.3 + 0.3*(2010-2000+1))*11/2/11, color = "red", size = 2) + 
  labs(x = "Estimate Size", y = "Density") + 
  theme(axis.title = element_text(size = 14))
```

---
# .center.pull[Simulation 2 - Staggered Treatment]

- <span style="color:maroon">  Main problem - we use *early treated units* as controls for later treated units, which violates the *parallel trends assumption*! <span> 

- When the treatment effect is "dynamic", i.e. takes more than one period to be incorporated into dependent variable, we are *subtracting* the treatment effects from prior treated units from the estimate of future control units. 

  - Recall the issue with $\Delta ATT > 0$ we discussed earlier. 

- This biases TWFE estimates towards zero even though all the treatment effects are positive. 

---
# .center.pull[Another Simulation]

- Can we actually get <span style="color:maroon"> estimates for $\color{maroon}{\delta}$ that are of the *wrong sign* </span>? Yes, if treatment effects for early treated units are larger (in absolute magnitude) than the treatment effects on later treated units. 

  - In this case, $\Delta ATT$ is positive and larger in absolute magnitude. 

- Let's simulate another example in which units are randomly assigned to one of 20 states. The 20 states are randomly assigned into one of 5 treatment groups $G_g$ based on treatment being initiated in 1993, 1997, 2001, 2005, and 2009. 

- All treated units incorporated in a state in treatment group $G_g$ receive a treatment effect $\delta_i \sim N(\delta_g, 0.04)$.

- The treatment effect is dynamic - $\delta_{it} = \delta_i \times (year - G_g)$.

---
# .center.pull[Another Simulation]

- The average treatment effect multiple decreases over time:

$\hspace{2cm}$

```{r d11, message = FALSE, error = FALSE, echo = FALSE, cache = TRUE, results = 'asis'}
treats <- tibble(
  "Cohort" = c(1993, 1997, 2001, 2005, 2009),
  "Effect" =  c(0.7, 0.4, 0.3, 0.2, 0.1)
)
kable(treats, format = "html", align = 'c', 
                booktabs = T, table.attr = "style='width:30%;'", caption = "<center><strong>Treatment Effect Averages</strong></center>", linesep = "") %>% 
  kable_styling(position = "center")
```

---
# .center.pull[Another Simulation]

```{r d12, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', cache = TRUE, fig.height = 6, fig.width = 10}
# set seed
set.seed(19910914)

# Fixed Effects ------------------------------------------------
# unit fixed effects
unit <- tibble(
  unit = 1:200, 
  unit_fe = rnorm(200, 0, 0.5),
  # generate state
  state = sample(1:20, 200, replace = TRUE))

# year fixed effects 
year <- tibble(
  year = 1990:2010,
  year_fe = rnorm(21, 0, 0.5))

# Trend Break -------------------------------------------------------------
# Put the states into treatment groups
treat_taus <- tibble(
  # sample the states randomly
  state = sample(1:20, 20, replace = FALSE),
  # place the randomly sampled states into five treatment groups G_g
  cohort_year = sort(rep(c(1993, 1997, 2001, 2005, 2009), 4)),
  # assign them a mean treatment effect from 0.5 to 0.1
  mu = sort(rep(c(.7, .4, .3, .2, .1), 4), decreasing = TRUE))

# make main dataset
# full interaction of unit X year 
data <- expand_grid(unit = 1:200, year = 1990:2010) %>% 
  left_join(., unit) %>% 
  left_join(., year)

# bring in the treatment indicators and values
get_treat <- function(u) {
  # get the state for the unit
  st <- unit %>% filter(unit == u) %>% pull(state)
  
  # find the treatment year for the state
  treat_yr <- treat_taus %>% filter(state == st) %>% pull(cohort_year)
  
  # treatment effect tau_g
  mu <- treat_taus %>% filter(state == st) %>% pull(mu)
  
  # Make a data set with the results 
  tibble(unit = rep(u, 21), 
         year = 1990:2010,
         # get a treatment cohort indicator
         # make treatment indicator
         treat = ifelse(year < treat_yr, 0, 1),
         # get the treatment effect \tau_i for post-treatment years
         cohort_year = treat_yr,
         static_tau = rep(rnorm(1, mu, 0.1), 21),
         tau = ifelse(year < treat_yr, 0, static_tau),
         # cumulate the effect
         tau_cum = cumsum(tau))
  }

# call the function over our 200 units
treatments <- map_dfr(1:200, get_treat)

# merge in the treatment effect data
data <- left_join(data, treatments) %>% 
  # simulate error and generate the dependent variable
  mutate(error = rnorm(4200, 0, 0.1),
         dep_var = unit_fe + year_fe + tau_cum + error)

sim3_plot <- data %>% 
ggplot(aes(x = year, y = dep_var, group = unit)) +
# unit specific lines
geom_line(alpha = 1/10, color = "grey") + 
# group specific averages
geom_line(
  data = . %>% 
    group_by(cohort_year, year) %>% 
    dplyr::summarize(dep_var = mean(dep_var)),
  aes(x = year, y = dep_var, group = factor(cohort_year),
      color = factor(cohort_year)), size = 1) + 
labs(x = "", y = "", color = "Group") + 
ggtitle("Trends in Outcome Path") +
geom_vline(xintercept = 1992.5, color = '#A7473A',
           linetype = "dashed", size = 1) + 
geom_vline(xintercept = 1996.5, color = '#4B5F6C',
           linetype = "dashed", size = 1) + 
geom_vline(xintercept = 2000.5, color = '#51806a',
           linetype = "dashed", size = 1) + 
geom_vline(xintercept = 2004.5, color = 'darkorange',
           linetype = "dashed", size = 1) + 
geom_vline(xintercept = 2008.5, color = 'skyblue',
           linetype = "dashed", size = 1) + 
scale_color_manual(values = c("#A7473A", "#4B5F6C", "#51806a", "darkorange", "skyblue")) + 
scale_y_continuous(limits = c(-10, 15)) + 
theme(legend.position = 'bottom',
      legend.title = element_blank(),
      plot.title = element_text(hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      axis.title.y = element_text(hjust = 0.5, vjust = 0.5, angle = 360))

sim3_plot
```

---
# .center.pull[Another Simulation]

- Let's look at the distribution of $\color{maroon}{\delta}$ using TWFE estimation with this simulated sample (red line represents 0 here).

```{r d13, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', cache = TRUE, fig.height = 6, fig.width = 10}
# set seed
set.seed(19910914)
runreg <- function(i){
  # Fixed Effects ------------------------------------------------
  # unit fixed effects
  unit <- tibble(
    unit = 1:200, 
    unit_fe = rnorm(200, 0, 0.5),
    # generate state
    state = sample(1:20, 200, replace = TRUE))
  
  # year fixed effects 
  year <- tibble(
    year = 1990:2010,
    year_fe = rnorm(21, 0, 0.5))
  
  # Trend Break -------------------------------------------------------------
  # Put the states into treatment groups
  treat_taus <- tibble(
    # sample the states randomly
    state = sample(1:20, 20, replace = FALSE),
    # place the randomly sampled states into five treatment groups G_g
    cohort_year = sort(rep(c(1993, 1997, 2001, 2005, 2009), 4)),
    # assign them a mean treatment effect from 0.5 to 0.1
    mu = sort(rep(c(.6, .4, .3, .2, .1), 4), decreasing = TRUE))
  
  # make main dataset
  # full interaction of unit X year 
  data <- expand_grid(unit = 1:200, year = 1990:2010) %>% 
    left_join(., unit) %>% 
    left_join(., year)
  
  # bring in the treatment indicators and values
  get_treat <- function(u) {
    # get the state for the unit
    st <- unit %>% filter(unit == u) %>% pull(state)
    
    # find the treatment year for the state
    treat_yr <- treat_taus %>% filter(state == st) %>% pull(cohort_year)
    
    # treatment effect tau_g
    mu <- treat_taus %>% filter(state == st) %>% pull(mu)
    
    # Make a data set with the results 
    tibble(unit = rep(u, 21), 
           year = 1990:2010,
           # get a treatment cohort indicator
           # make treatment indicator
           treat = ifelse(year < treat_yr, 0, 1),
           # get the treatment effect \tau_i for post-treatment years
           cohort_year = treat_yr,
           static_tau = rep(rnorm(1, mu, 0.05), 21),
           tau = ifelse(year < treat_yr, 0, static_tau),
           # cumulate the effect
           tau_cum = cumsum(tau))
    }
  
  # call the function over our 200 units
  treatments <- map_dfr(1:200, get_treat)
  
  # merge in the treatment effect data
  data <- left_join(data, treatments) %>% 
    # simulate error and generate the dependent variable
    mutate(error = rnorm(4200, 0, 0.1),
           dep_var = unit_fe + year_fe + tau_cum + error)
  
   broom::tidy(felm(dep_var ~ treat | unit + year | 0 | state, data = data,
                   exactDOF = TRUE, cmethod = "reghdfe"))
}
simdata <- map_dfr(1:500, runreg)

simdata %>% 
  ggplot(aes(x = estimate)) + 
  geom_density(fill = "gray", alpha = 1/2) + 
  geom_vline(xintercept = 0, color = "red", size = 2) + 
  labs(x = "Estimate Size", y = "Density") + 
  theme(axis.title = element_text(size = 14))
```

---
# .center.pull[Goodman-Bacon Decomposition]

```{r d14, echo = FALSE, warning = FALSE, message = FALSE, results = FALSE, fig.align = 'center', cache = TRUE, fig.width = 10}
# unit fixed effects
unit <- tibble(
  unit = 1:200, 
  unit_fe = rnorm(200, 0, 0.5),
  # generate state
  state = sample(1:20, 200, replace = TRUE))
# year fixed effects 
year <- tibble(
  year = 1990:2010,
  year_fe = rnorm(21, 0, 0.5))
# Trend Break -------------------------------------------------------------
# Put the states into treatment groups
treat_taus <- tibble(
  # sample the states randomly
  state = sample(1:20, 20, replace = FALSE),
  # place the randomly sampled states into five treatment groups G_g
  cohort_year = sort(rep(c(1993, 1997, 2001, 2005, 2009), 4)),
  # assign them a mean treatment effect from 0.5 to 0.1
  mu = sort(rep(c(.7, .4, .3, .2, .1), 4), decreasing = TRUE))
# make main dataset
# full interaction of unit X year 
data <- expand_grid(unit = 1:200, year = 1990:2010) %>% 
  left_join(., unit) %>% 
  left_join(., year)
# bring in the treatment indicators and values
get_treat <- function(u) {
  # get the state for the unit
  st <- unit %>% filter(unit == u) %>% pull(state)
  
  # find the treatment year for the state
  treat_yr <- treat_taus %>% filter(state == st) %>% pull(cohort_year)
  
  # treatment effect tau_g
  mu <- treat_taus %>% filter(state == st) %>% pull(mu)
  
  # Make a data set with the results 
  tibble(unit = rep(u, 21), 
         year = 1990:2010,
         # get a treatment cohort indicator
         # make treatment indicator
         treat = ifelse(year < treat_yr, 0, 1),
         # get the treatment effect \tau_i for post-treatment years
         cohort_year = treat_yr,
         static_tau = rep(rnorm(1, mu, 0.05), 21),
         tau = ifelse(year < treat_yr, 0, static_tau),
         # cumulate the effect
         tau_cum = cumsum(tau))
  }
# call the function over our 200 firms
treatments <- map_dfr(1:200, get_treat)
# merge in the treatment effect data
data <- left_join(data, treatments) %>% 
  # simulate error and generate the dependent variable
  mutate(error = rnorm(4200, 0, 0.1),
         dep_var = unit_fe + year_fe + tau_cum + error)
# calculate the bacon decomposition without covariates
bacon_out <- bacon(dep_var ~ treat,
                   data = data,
                   id_var = "unit",
                   time_var = "year")
```


```{r d15, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', cache = TRUE, fig.width = 10}
bacon_out %>% 
  ggplot(aes(x = weight, y = estimate, shape = factor(type), color = factor(type))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) +
  scale_colour_brewer(palette = 'Set1') + 
  labs(x = "Weight", y = "Estimate") + 
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 16))
```


---
# .center.pull[Outline of Lecture]

$\hspace{2cm}$

1. <span style="color:maroon"> Overview of Difference-in-Differences (DiD) </span>

2. <span style="color:maroon"> Two-Way Fixed Effects (TWFE) Estimator </span>

3. <span style="color:maroon"> Problems with Using TWFE Estimator for DiD with Multiple Time Periods </span>

4. <span style="color:maroon"> Simulation Examples </span>

5. <span style="color:maroon"> Alternative Difference-in-Differences Estimators </span>

6. Conclusion and Recommendations

---
# .center.pull[Callaway & Sant'Anna (CS)]

- CS estimator starts with <span style="color:maroon"> group-time average treatment effects - $ATT_(g,t)$ </span>. 

  - Consider a treatment group $g$ that have $t$ time periods and CS breaks it down to many 2x2 DiD. 
  
  - For each 2x2 DiD, estimate $ATT_(g,t) = E[Y_t(g)-Y_t(0)|G_g = 1]$.
  
  - Only <span style="color:maroon"> clean controls (never treated or not yet treated) </span> are used. 

- There are multiple ways to aggregate group-time average treatment effects. 

  - Aggregate by treatment group $g$. 
  
  - Aggregate by relative time to treatment (event study): $t-g=e$. 
  
  - A single aggregated ATT: $t \ge g$.

---
# .center.pull[Callaway & Sant'Anna (CS)]

```{r d16, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', cache = TRUE, fig.width = 10}
# create a lead/lag indicators
data <- data %>% 
  # variable with relative year from treatment
  mutate(rel_year = year - cohort_year) %>% 
  # drop observations after 2008 bc all treated 
  filter(year <= 2008) %>% 
  dplyr::arrange(cohort_year, unit, year)
# first get percentage contribution to each lead/lag indicator by treatment cohort for weights
# we will need this for the Abraham/Sun method, as well as the true treatment indicator
# calculate weights
weights <- data %>% 
  mutate(rel_year = year - cohort_year) %>% 
  # drop covariates for 2009 adopters
  filter(cohort_year != 2009) %>% 
  group_by(cohort_year, rel_year) %>% 
  count %>% 
  ungroup() %>% 
  group_by(rel_year) %>% 
  mutate(total = sum(n),
         perc = n / total) %>% 
  # keep just the variables we need
  dplyr::select(rel_year, cohort_year, perc) %>% 
  ungroup() %>% 
  rowwise() %>% 
  # add variable equal to coefficient from regression
  mutate(term = paste("cohort_year_", cohort_year, "_", rel_year + 19, sep = "")) %>% 
  ungroup()
# make a dataset with the theoretical values to merge in
true_effect <- weights %>% 
  # add in the multiples
  mutate(
    multiple = case_when(
      rel_year < 0 ~ 0,
      rel_year >= 0 ~ rel_year + 1),
    # add in the tau_g values 
    tau_g = case_when(
      cohort_year == 1993 ~ .7,
      cohort_year == 1997 ~ .4,
      cohort_year == 2001 ~ .3,
      cohort_year == 2005 ~ .2),
    # multiply the two 
    effect = multiple*tau_g) %>% 
  #collapse by  time period 
  group_by(rel_year) %>% 
  summarize(true_tau = weighted.mean(effect, w = perc)) %>% 
  # make the time variable for merging
  mutate(t = rel_year)

# run the CS algorithm
CS_out <- att_gt("dep_var", data = data,
                 gname="cohort_year",
                 idname="unit", tname="year", 
                 clustervars = "state",
                 bstrap=T, cband=T,
                 control_group = c("notyettreated"),
                 print_details = F)

aggte <- aggte(CS_out, type = "dynamic")

# plot
tibble(
  t = -10:10,
  estimate = aggte$att.egt[5:25],
  se = aggte$se.egt[5:25],
  conf.low = estimate - 1.96*se,
  conf.high = estimate + 1.96*se,) %>% 
  left_join(true_effect) %>% 
  # split the error bands by pre-post
  mutate(band_groups = case_when(
    t < -1 ~ "Pre",
    t >= 0 ~ "Post",
    t == -1 ~ ""
  )) %>%
  # plot
  ggplot(aes(x = t, y = estimate)) + 
  geom_line(aes(x = t, y = true_tau, color = "True Effect"), size = 1.5, linetype = "dashed") + 
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = band_groups),
              color = "lightgrey", alpha = 1/4) + 
  #geom_point(aes(color = "Estimated Effect")) + 
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high, color = "Estimated Effect"), show.legend = FALSE) + 
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = -0.5, linetype = "dashed") + 
  scale_x_continuous(breaks = -10:10) + 
  labs(x = "Relative Time", y = "Estimate") +
  scale_color_brewer(palette = 'Set1') + 
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 16)) 
```

---
# .center.pull[Sun and Abraham (SA)]

- SA can be viewed as an <span style="color:maroon"> extension of the standard event study TWFE model </span>:

$$y_{it} = \alpha_i + \alpha_t + \sum_e \sum_{l \neq -1} \delta_{el}(1\{E_i = e\} \cdot D_{it}^l) + \epsilon_{it}$$
  
  - In the regression above, $e$ denotes treatment group and $l$ denotes relative time to treatment. 
  
- Similar to CS estimator, SA estimator also uses <span style="color:maroon"> clean controls (never treated or last treated) </span>. 

- We saturate the relative time indicators (i.e. t = -2, -1, ...) with treatment group indicators, and aggregate to overall aggregate relative time indicators by cohort size.

- In the case of no covariates, this gives you the same estimate as CS estimator if you fully saturate the model with time indicators (leaving only two relative year identifiers missing).

- The authors don't claim that it can be used with covariates, but it seemingly follows if we think it is okay with normal TWFE DiD. 

---
# .center.pull[Sun and Abraham (SA)]

```{r d17, echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center', cache = TRUE, fig.width = 10}
## Make cohort-relative time dummies
# relative year dummies
rel_year <- data %>% select(rel_year) %>% 
  dummy_cols %>% select(-1) %>% 
  set_colnames(as.numeric(str_remove(colnames(.), "rel_year_")) + 19) %>% 
  as.data.frame
# cohort dummies
cohorts <- data %>% select(cohort_year) %>% 
  dummy_cols %>% select(-1) %>% 
  as.data.frame
# combine matrix functions
combine_mat <- function(i) {
  cohorts[, i] * rel_year %>% 
    set_colnames(paste(colnames(cohorts)[i], colnames(rel_year), sep = "_"))
}
# combine dummies and merge into our data
dummies <- map_dfc(1:4, combine_mat)
data <- data %>% bind_cols(dummies)
# put the covariates into a vector form
covs <- paste("cohort_year_", rep(c(1993, 1997, 2001, 2005), 33), "_", c(-18:-2, 0:15) + 19, sep = "")
# estimate the saturated model
fit <- felm(as.formula(paste("dep_var ~ ", paste(covs, collapse = "+"), "| unit + year | 0 | state")), 
            data = data, exactDOF = TRUE)
# rerun without the NA covariates because glmt won't run otherwise
# new set of covariates without the na
covs <- broom::tidy(fit) %>% filter(!is.na(estimate)) %>% pull(term)
fit <- felm(as.formula(paste("dep_var ~ ", paste(covs, collapse = "+"), "| unit + year | 0 | state")), 
            data = data, exactDOF = TRUE)
# get the coefficients and make a dataset for plotting
coefs <- fit$coefficients %>%
  # add in coefficient name to tibble
  as_tibble(rownames = "term") %>% 
  # bring in weights
  left_join(., weights)
# get the relevant coefficients and weights into a string to get the linear combination
get_lincom <- function(ll) {
  # get just the coefficients for a specific lead lag
  cf2 <- coefs %>% filter(rel_year == ll)
  # paste the function that goes into the linear combination function
  F <- paste(paste(cf2$perc, cf2$term, sep = " * ", collapse = " + "), " = 0")
  # take linear combination and put into a data frame
  broom::tidy(
    confint(glht(fit, linfct = F)),
    conf.int = TRUE
  ) %>% mutate(rel_year = ll)
}
# run over all lead/lags
AS_plot <- map_df(c(-10:-2, 0:10), get_lincom) %>% 
  # add time variable
  mutate(t = c(-10:-2, 0:10))
#Plot the results
AS_plot %>% 
  select(t, estimate, conf.low, conf.high) %>% 
  # add in data for year -1
  bind_rows(tibble(t = -1, estimate = 0, 
                   conf.low = 0, conf.high = 0
  )) %>% 
  left_join(true_effect) %>% 
  # split the error bands by pre-post
  mutate(band_groups = case_when(
    t < -1 ~ "Pre",
    t >= 0 ~ "Post",
    t == -1 ~ ""
  )) %>%
  # plot
  ggplot(aes(x = t, y = estimate)) + 
  geom_line(aes(x = t, y = true_tau, color = "True Effect"), size = 1.5, linetype = "dashed") + 
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = band_groups),
              color = "lightgrey", alpha = 1/4) + 
  #geom_point(aes(color = "Estimated Effect")) + 
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high, color = "Estimated Effect"), show.legend = FALSE) + 
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = -0.5, linetype = "dashed") + 
  scale_x_continuous(breaks = -10:10) + 
  labs(x = "Relative Time", y = "Estimate") +
  scale_color_brewer(palette = 'Set1') + 
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 16))
```


---
# .center.pull[Model Comparison]

- **Callaway & Sant'Anna**
  
  - Can be <span style="color:maroon"> very flexible in determining which control units to use, including never treated and not yet treated </span>. 
  - Has a more flexible functional form as well (easier to adjust for pre-treatment covariates).
  - <span style="color:maroon"> Doubly robust </span> estimation: combine propensity score and outcome regression so that we will get unbiased estimate if either model specification is correct.

- **Abraham & Sun** 
  
  - Very <span style="color:maroon">similar to regular TWFE </span> and thus easy to explain. 
  - Control units are not treated or last treated within the data sample. If most of the units are treated by the end (or all), this can make <span style="color:maroon"> control units very non-representative and restricted </span>.

---
# .center.pull[Outline of Lecture]

$\hspace{2cm}$

1. <span style="color:maroon"> Overview of Difference-in-Differences (DiD) </span>

2. <span style="color:maroon"> Two-Way Fixed Effects (TWFE) Estimator </span>

3. <span style="color:maroon"> Problems with Using TWFE Estimator for DiD with Multiple Time Periods </span>

4. <span style="color:maroon"> Simulation Examples </span>

5. <span style="color:maroon"> Alternative Difference-in-Differences Estimators  </span>

6. <span style="color:maroon"> Conclusion and Recommendations  </span>

---
# .center.pull[What Are The Best Practices?]

- TWFE can produce unbiased estimate of staggered DiD when:  
  - there is only a <span style="color:maroon"> single treatment period </span>; 
  - the treatment effects are <span style="color:maroon"> homogeneous </span>, however, we usually do not know if the treatments are homogeneous or not. 

- When there are multiple time periods, we should consider to: 
  - plot the <span style="color:maroon"> treatment timing across cohorts </span>; 
  - decompose the TWFE estimator with <span style="color:maroon"> Bacon-decomposition </span>. 

- When using event-study specification, we should <span style="color:maroon"> avoid binning relative-time periods </span> unless we have reasons to believe homogeneous effects apply in the relative-time periods within a bin.

---

# .center.pull[Plot Treatment Timing Across Cohort]
<center>

<img src="Plot treatment timing across cohorts.png", height = "33%", width = "33%">

---
# .center.pull[What Are The Best Practices?]

- If there is justifiable concern for bias, we should apply at least one of the <span style="color:maroon"> alternative estimators </span>.
  - *Callaway & Sant'Anna, Abraham and Sun, de Chaisemartin-D'Haultfoeuille, etc.*

- When using the alternative estimators, we should justify their choice of <span style="color:maroon"> clean comparison groups (never treated or not yet treated) </span> and articulate why the parallel-trends assumption is likely to apply.

- Regardless of the estimators used, static DiD estimates should be accompanied by <span style="color:maroon"> event-study estimates </span>. 

- It is good practice to use more than one alternative estimators and check if the estimates are consistent. 

---

# .center.pull[Five Different Estimators]
<center>

<img src="https://raw.githubusercontent.com/borusyak/did_imputation/main/five_estimators_example.png", width = "62%">

---

# .center.pull[Seven Different Estimators]
<center>

<img src="https://raw.githubusercontent.com/pietrosantoleri/staggered_did/main/output/seven_estimators_example_allt.png", width = "65%">


---
# .center.pull[Takeaways]

- TWFE estimator is a power tool and we should still use it for DiD when appropriate.

- However, we should make sure we understand what we're doing. DiD is a <span style="color:maroon"> comparison of means </span> and at a minimum we should know which means we're comparing. 

- Multiple new methods have been proposed, all of which ensure that you <span style="color:maroon"> aren't using prior treated units as controls </span>. 

- You should probably tailor your selection of method to your <span style="color:maroon"> data structure </span>: they use and discard different amount of control units and depending on your setting this might matter. 

---
# .center.pull[References]

1. Baker, Andrew C., David F. Larcker, and Charles C. Y. Wang. 2022. “How Much Should We Trust Staggered Difference-in-Differences Estimates?” Journal of Financial Economics 144 (2): 370–95. https://doi.org/10.1016/j.jfineco.2022.01.004.

2. Borusyak, Kirill, Xavier Jaravel, and Jann Spiess. 2022. “Revisiting Event Study Designs: Robust and Efficient Estimation.” arXiv. https://doi.org/10.48550/arXiv.2108.12419.

3. Callaway, Brantly, and Pedro H. C. Sant’Anna. 2021. “Difference-in-Differences with Multiple Time Periods.” Journal of Econometrics, Themed Issue: Treatment Effect 1, 225 (2): 200–230. https://doi.org/10.1016/j.jeconom.2020.12.001.

4. Goodman-Bacon, Andrew. “Difference-in-Differences with Variation in Treatment Timing.” Journal of Econometrics, Themed Issue: Treatment Effect 1, 225, no. 2 (December 1, 2021): 254–77. https://doi.org/10.1016/j.jeconom.2021.03.014.

5. Sun, Liyang. 2021. EVENTSTUDYINTERACT: Stata Module to Implement the Interaction Weighted Estimator for an Event Study. Statistical Software Components. https://econpapers.repec.org/software/bocbocode/S458978.htm.
